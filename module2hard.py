# Слишком древний шифр


# Задаем последовательность

num1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]


# Задаем функцию для расчета
def its_alive():
    while num2 == []:  # Цикл вычислений повторяется пока список не заполнится значениями
        for i in num1:  # Перебираем числа (из списка num1) для первой цифры пары
            for j in num1:  # Перебираем числа (из списка num1) для второй цифры пары
                if i <= j:  # Ограничение: первая цифра пары не должна быть больше второй цифры пары
                    if iter % (i + j) == 0 and j != i:  # Проверяем кратность чисел, исключаем дублирование
                        num2.append(i)  # Добавляем первую цифру
                        num2.append(j)  # Добавляем вторую цифру
        return num2  # Возвращаем список с полученными значениями


# Задаем функцию для проверки результата
def check():
    list_of_true = ['12', '13', '1423', '121524', '162534', '13172635', '1218273645', '141923283746',
                    '11029384756', '12131511124210394857', '112211310495867', '1611325212343114105968',
                    '1214114232133124115106978', '1317115262143531341251161079', '11621531441351261171089',
                    '12151811724272163631545414513612711810', '118217316415514613712811910',
                    '13141911923282183731746416515614713812911']  # Список верных значений
    while True:
        rec = input('\nПроверить полученный пароль вручную или автоматически? (Руч/Авто):\n> ')  # Выбор способа проверки
        rec = rec.lower()  # Правим регистр
        if rec == 'авто':  # Автопроверка
            while True:
                if num2 in list_of_true:  # Проверяем есть ли значение в списке list_of_true
                    print('\nПароль верный!')
                    break # Завершаем текущий вложенный цикл
                else:
                    print('\nПароль и введенная последовательность не совпадают!')
                    break # Завершаем текущий вложенный цикл
            break # Завершаем цикл проверки
        elif rec == 'руч':  # Ручная проверка
            check = str(input(f'\n\nВведите последовательность из задания для цифры {iter}'
                              f' (без пробелов и знаков препинания):\n> '))
            if num2 == check:  # Сравнение введенных цифр и расчитанной последовательности
                print('\nПароль верный!')
                break   # Завершаем цикл проверки
            else:
                print('\nПароль и введенная последовательность не совпадают!')
                break   # Завершаем цикл проверки
        else:
            print('\nВы ввели неверное значение!')
            continue


# Задаем основной цикл программы

que = 'да'  # Триггер включения - выключения повтора
while que == 'да':
    iter = int(input('Введите число от 3 до 20:\n> '))
    num2 = []
    if iter in num1[2:]:  # Проверяем входит ли введенное число в искомые
        its_alive()  # Активируем функцию расчета
    else:
        print('\nВы ввели неверное число\n')
        continue
    print('\nПолучился пароль: ')
    print(*num2) # Выводим пароль в виде списка без знаков
    num2 = "".join(str(num2[0]) for num2[0] in num2)  # Преобразуем список в строку для проверки
    check() # Проверка результата
    while True: # Цикл выбора: повторять или нет программу
        que2 = input('\nЖелаете повторить? (Да/Нет):\n> ')
        que2 = que2.lower()
        if que2 == 'да':
            que = que2
            break
        elif que2 == 'нет':
            que = que2
            break
        else:
            print('\nВы ввели неверное значение!')
            continue
    print('\n\n\n')

# Заврешить

print('Вычисления завершены! Спасибо!')
